{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# How to find the 2D Basis of a Plane using GBpy!"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Follow the installation manual to receive the byxtal package and import all the required packages that we need for completing this tutorial."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {},
   "outputs": [],
   "source": [
    "import byxtal as bxt\n",
    "import numpy as np\n",
    "from sympy.matrices import Matrix, eye, zeros;"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Miller Indices and Common Conventions:\n",
    "\n",
    "Miller Indices are often used to refer to a given crystallograohic plane in crystals. However various conventions are commonly used in determining the Miller Indices that can completely change the plane of reference. For this reason we would like to declare our conventions in defining the Miller Indices to avoid any confusions. By definition Miller Indices are defined as the reciprocal of intercepts of a crystallographic plane with the Unit Cell Basis Vectors. The confusion is often caused by the definition of the Unit Cell. In f.c.c and b.c.c lattices primitive basis vectors are non-orthogonal while the supercell basis vectors are orthogonal. Most importantly since the reciprocal and direct lattices are the identical in f.c.c and b.c.c, the Miller Indices (defined in supercell unit cell) are the same as the plane normal indices. This unique property and convenience of using an orthogonal set of basis vectors is the root cause of the bipartisan approach to defining the Miller Indices. The downfall of such an approach is the fact that it does not have much utility in other types of lattices e.g. hcp. Therefore in GBpy whenever we use the term Miller Indices, we are referring to the reciprocals of intercepts of a crystallographic plane with the primitive Basis Vectors.\n",
    "\n",
    "Miller Indices: reciprocal of intercepts of a crystallographic plane with the primitive Basis Vectors\n",
    "\n",
    "or alternatively\n",
    "\n",
    "Miller Indices: normal vector indices of the plane defined in primitive reciprocal lattice\n",
    "\n",
    "The above interchangeable definitions are consistently used in GBpy for referring to Miller Indices. Other conventions in defining the Miller Indices are ultimately converted to the above definition.\n",
    "\n",
    "In the present tutorial we manually extract various Indices and demonstrate how they can be fed to the GBpy. In practice such conversions are not necessary as long as the user is consistent with the definitions of GBpy, and can be used for verifying the answer."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Problem Definition:\n",
    "\n",
    "In this tutorial we would like to find the planar basis of a plane with $[2 3 1]$ normal vector defined in supercell f.c.c basis .\n",
    "\n",
    "Since the normal vector to the plane is provided in the orthogonal f.c.c basis (supercell basis), first we need to obtain the Miller Indices of the plane to be able to use the byxtal package."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Finding Miller Indices:\n",
    "\n",
    "A vector in the space can be expressed in any basis, of course with varying components. Vector $\\vec{v}$ in basis A can be expressed as:\n",
    "\n",
    "$$ \n",
    "\\vec{v} = \\mathcal{B}_A v_A\n",
    "$$\n",
    "\n",
    "Similarly we can define the plane normal $\\vec{n}$ in any basis. For instance we can define $\\vec{n}$ in supercell f.c.c basis ($\\mathcal{B}_{po}$) or in primitive f.c.c basis $\\left( \\mathcal{B}_p \\right) $; we can write:\n",
    "\n",
    "We can express the right hand side of the (2) as:\n",
    "\n",
    "where:\n",
    "\n",
    "$\\Lambda_p^{po}$ is a 3x3 matrix with its columns being the components of basis vectors of po in p basis."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([[0. , 0.5, 0.5],\n",
       "       [0.5, 0. , 0.5],\n",
       "       [0.5, 0.5, 0. ]])"
      ]
     },
     "execution_count": 4,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "l_p_po = 1.0 * np.array([[0.,0.5,0.5],[0.5,0.,0.5],[0.5,0.5,0.]])\n",
    "l_p_po"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "From (6) we need to find the reciprocal of the $\\Lambda_{p}_{po}$. To do so use the `bxt.find_csl_dsc.reciprocal_mat()`. For the sake of convenience we abbreviate the imported function `bxt.find_csl_dsc` as `fcd`:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/latex": [
       "$\\displaystyle \\left[\\begin{matrix}-1.0 & 1.0 & 1.0\\\\1.0 & -1.0 & 1.0\\\\1.0 & 1.0 & -1.0\\end{matrix}\\right]$"
      ],
      "text/plain": [
       "Matrix([\n",
       "[-1.0,  1.0,  1.0],\n",
       "[ 1.0, -1.0,  1.0],\n",
       "[ 1.0,  1.0, -1.0]])"
      ]
     },
     "execution_count": 7,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "import byxtal.find_csl_dsc as fcd\n",
    "l_rp_po = fcd.reciprocal_mat(l_p_po)\n",
    "l_rp_po"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "l_po_rp = (l_rp_po)\n",
    "l_po_rp"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Finding the Planar Basis:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.3"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
